<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Unreal Engine Gameplay Framework - 3D Architecture</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0f;
            color: #e0e0e0;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }
        
        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        
        canvas {
            display: block;
        }
        
        .header {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
            width: 95%;
        }
        
        .header h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(14px, 4vw, 28px);
            font-weight: 900;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: clamp(1px, 0.5vw, 4px);
            text-shadow: 0 0 30px rgba(0, 150, 255, 0.5), 0 0 60px rgba(0, 150, 255, 0.3);
            margin-bottom: 4px;
        }
        
        .header p {
            font-size: clamp(10px, 2.5vw, 14px);
            color: #888;
            letter-spacing: 1px;
        }
        
        /* Collapsible Panel Base Styles */
        .panel {
            background: rgba(10, 10, 20, 0.92);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-radius: 8px;
            z-index: 100;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 12px 15px;
        }
        
        .panel-header h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: #0af;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0;
        }
        
        .panel-toggle {
            color: #0af;
            font-size: 18px;
            transition: transform 0.3s ease;
        }
        
        .panel.collapsed .panel-toggle {
            transform: rotate(180deg);
        }
        
        .panel-content {
            padding: 0 15px 15px;
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }
        
        .panel.collapsed .panel-content {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        .legend {
            position: absolute;
            top: 70px;
            left: 10px;
            max-width: 280px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            font-size: 12px;
        }
        
        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            margin-right: 10px;
            flex-shrink: 0;
        }
        
        .legend-item span {
            line-height: 1.3;
        }
        
        .server-only { background: linear-gradient(135deg, #ff4444, #aa2222); box-shadow: 0 0 10px rgba(255, 68, 68, 0.5); }
        .all-clients { background: linear-gradient(135deg, #44ff88, #22aa44); box-shadow: 0 0 10px rgba(68, 255, 136, 0.5); }
        .owning-client { background: linear-gradient(135deg, #ffaa44, #aa6622); box-shadow: 0 0 10px rgba(255, 170, 68, 0.5); }
        .local-only { background: linear-gradient(135deg, #aa44ff, #6622aa); box-shadow: 0 0 10px rgba(170, 68, 255, 0.5); }
        
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 10px;
            right: 10px;
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            z-index: 250;
            backdrop-filter: blur(10px);
            display: none;
            max-height: 40vh;
            overflow-y: auto;
        }
        
        .info-panel.active {
            display: block;
        }
        
        .info-panel h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(14px, 3.5vw, 18px);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .info-panel .badge {
            font-size: 9px;
            padding: 4px 8px;
            border-radius: 20px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
        }
        
        .info-panel p {
            font-size: clamp(12px, 3vw, 14px);
            line-height: 1.5;
            color: #bbb;
        }
        
        .info-panel .key-points {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .info-panel .key-point {
            background: rgba(0, 150, 255, 0.1);
            border: 1px solid rgba(0, 150, 255, 0.3);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .controls {
            position: absolute;
            top: 70px;
            right: 10px;
            max-width: 180px;
        }
        
        .controls p {
            font-size: 11px;
            color: #888;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .controls .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            color: #fff;
        }
        
        .close-btn {
            position: absolute;
            top: 8px;
            right: 10px;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 24px;
            line-height: 1;
            padding: 5px;
        }
        
        .close-btn:hover, .close-btn:active {
            color: #fff;
        }

        .relationships {
            position: absolute;
            bottom: 10px;
            right: 10px;
            max-width: 240px;
        }

        .relationship-item {
            font-size: 10px;
            color: #888;
            margin-bottom: 5px;
            padding-left: 8px;
            border-left: 2px solid rgba(0, 150, 255, 0.3);
        }

        .relationship-item strong {
            color: #fff;
        }
        
        /* Mobile Drawer */
        .mobile-drawer {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(10, 10, 20, 0.95);
            border-top: 1px solid rgba(0, 150, 255, 0.4);
            border-radius: 16px 16px 0 0;
            z-index: 200;
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
            max-height: 60vh;
        }
        
        .mobile-drawer.collapsed {
            transform: translateY(calc(100% - 50px));
        }
        
        .drawer-handle {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            cursor: pointer;
        }
        
        .handle-bar {
            width: 40px;
            height: 4px;
            background: rgba(0, 150, 255, 0.5);
            border-radius: 2px;
            margin-bottom: 8px;
        }
        
        .drawer-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: #0af;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .drawer-content {
            padding: 0 15px 20px;
            overflow-y: auto;
            max-height: calc(60vh - 60px);
        }
        
        .drawer-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(0, 150, 255, 0.2);
            padding-bottom: 10px;
        }
        
        .tab-btn {
            flex: 1;
            background: rgba(0, 150, 255, 0.1);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-radius: 6px;
            padding: 10px 12px;
            color: #888;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tab-btn.active {
            background: rgba(0, 150, 255, 0.3);
            color: #fff;
            border-color: #0af;
        }
        
        .tab-content {
            animation: fadeIn 0.2s ease;
        }
        
        .tab-content.hidden {
            display: none;
        }
        
        .tab-content p {
            font-size: 13px;
            color: #888;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .tab-content .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 10px;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: #fff;
        }
        
        .tab-content .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            font-size: 13px;
        }
        
        .tab-content .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            margin-right: 12px;
            flex-shrink: 0;
        }
        
        .tab-content .relationship-item {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
            padding-left: 10px;
            border-left: 2px solid rgba(0, 150, 255, 0.3);
        }
        
        .tab-content .relationship-item strong {
            color: #fff;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Desktop panels container */
        .desktop-only {
            display: block;
        }
        
        /* Mobile touch hint */
        .touch-hint {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform: translate(-50%, 50%);
            background: rgba(0, 150, 255, 0.2);
            border: 1px solid rgba(0, 150, 255, 0.4);
            border-radius: 12px;
            padding: 15px 25px;
            z-index: 90;
            text-align: center;
            pointer-events: none;
            opacity: 1;
            transition: opacity 1s ease;
        }
        
        .touch-hint.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .touch-hint p {
            font-size: 14px;
            color: #0af;
            margin: 5px 0;
        }
        
        .touch-hint .icon {
            font-size: 30px;
            margin-bottom: 5px;
        }
        
        /* Reset button */
        .reset-btn {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 150, 255, 0.2);
            border: 1px solid rgba(0, 150, 255, 0.4);
            border-radius: 8px;
            padding: 10px 20px;
            color: #0af;
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s ease;
            display: none;
        }
        
        .reset-btn:hover, .reset-btn:active {
            background: rgba(0, 150, 255, 0.4);
        }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .header {
                top: 5px;
            }
            
            .desktop-only {
                display: none;
            }
            
            .mobile-drawer {
                display: block;
            }
            
            .reset-btn {
                display: block;
                top: auto;
                bottom: 70px;
                left: 50%;
                transform: translateX(-50%);
            }
            
            .info-panel {
                position: fixed;
                bottom: auto;
                top: 50%;
                left: 10px;
                right: 10px;
                transform: translateY(-50%);
                padding: 15px;
                max-height: 50vh;
                z-index: 300;
            }
            
            .touch-hint {
                bottom: 55%;
            }
        }
        
        @media (max-width: 480px) {
            .header h1 {
                font-size: 12px;
                letter-spacing: 1px;
            }
            
            .header p {
                font-size: 9px;
            }
            
            .tab-btn {
                padding: 8px 6px;
                font-size: 9px;
            }
            
            .drawer-content {
                padding: 0 12px 15px;
            }
            
            .legend-item {
                font-size: 11px;
            }
            
            .relationship-item {
                font-size: 11px;
            }
        }
        
        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .mobile-drawer {
                max-height: 50vh;
            }
            
            .mobile-drawer.collapsed {
                transform: translateY(calc(100% - 40px));
            }
            
            .drawer-content {
                max-height: calc(50vh - 50px);
            }
            
            .touch-hint {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="header">
        <h1>Unreal Engine Gameplay Framework</h1>
        <p>Interactive 3D Architecture</p>
    </div>
    
    <div class="touch-hint" id="touch-hint">
        <div class="icon">ðŸ‘†</div>
        <p>Drag to rotate</p>
        <p>Pinch to zoom</p>
        <p>Tap class to learn more</p>
    </div>
    
    <button class="reset-btn" id="reset-btn">Reset View</button>
    
    <!-- Mobile bottom drawer -->
    <div class="mobile-drawer" id="mobile-drawer">
        <div class="drawer-handle" onclick="toggleDrawer()">
            <span class="handle-bar"></span>
            <span class="drawer-title">Info Panel</span>
        </div>
        <div class="drawer-content">
            <div class="drawer-tabs">
                <button class="tab-btn active" onclick="switchTab('legend')">Legend</button>
                <button class="tab-btn" onclick="switchTab('controls')">Controls</button>
                <button class="tab-btn" onclick="switchTab('relations')">Relations</button>
            </div>
            
            <div class="tab-content" id="tab-legend">
                <div class="legend-item">
                    <div class="legend-color server-only"></div>
                    <span><strong>Server Only</strong> - Exists only on server</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color all-clients"></div>
                    <span><strong>Replicated</strong> - Server + all clients</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color owning-client"></div>
                    <span><strong>Server + Owner</strong> - Not other clients</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color local-only"></div>
                    <span><strong>Local Only</strong> - Each machine separately</span>
                </div>
            </div>
            
            <div class="tab-content hidden" id="tab-controls">
                <p><span class="key">Drag</span> Rotate view</p>
                <p><span class="key">Pinch</span> Zoom in/out</p>
                <p><span class="key">Tap</span> Select class</p>
                <p><span class="key">R</span> Reset view (desktop)</p>
            </div>
            
            <div class="tab-content hidden" id="tab-relations">
                <div class="relationship-item"><strong>GameMode</strong> spawns PlayerController, Pawn, States</div>
                <div class="relationship-item"><strong>PlayerController</strong> possesses Pawn, owns HUD</div>
                <div class="relationship-item"><strong>PlayerState</strong> persists across Pawn deaths</div>
                <div class="relationship-item"><strong>GameState</strong> holds all PlayerStates</div>
                <div class="relationship-item"><strong>GameInstance</strong> persists across levels</div>
            </div>
        </div>
    </div>
    
    <!-- Desktop panels (hidden on mobile) -->
    <div class="desktop-only">
        <div class="legend panel" id="legend-panel">
            <div class="panel-header" onclick="togglePanel('legend-panel')">
                <h3>Network Presence</h3>
                <span class="panel-toggle">â–¼</span>
            </div>
            <div class="panel-content">
                <div class="legend-item">
                    <div class="legend-color server-only"></div>
                    <span><strong>Server Only</strong> - Exists only on server</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color all-clients"></div>
                    <span><strong>Replicated</strong> - Server + all clients</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color owning-client"></div>
                    <span><strong>Server + Owner</strong> - Not other clients</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color local-only"></div>
                    <span><strong>Local Only</strong> - Each machine separately</span>
                </div>
            </div>
        </div>
        
        <div class="controls panel" id="controls-panel">
            <div class="panel-header" onclick="togglePanel('controls-panel')">
                <h3>Controls</h3>
                <span class="panel-toggle">â–¼</span>
            </div>
            <div class="panel-content">
                <p><span class="key">Drag</span> Rotate</p>
                <p><span class="key">Scroll</span> Zoom</p>
                <p><span class="key">Click</span> Select</p>
            </div>
        </div>

        <div class="relationships panel" id="relationships-panel">
            <div class="panel-header" onclick="togglePanel('relationships-panel')">
                <h3>Relationships</h3>
                <span class="panel-toggle">â–¼</span>
            </div>
            <div class="panel-content">
                <div class="relationship-item"><strong>GameMode</strong> spawns PlayerController, Pawn, States</div>
                <div class="relationship-item"><strong>PlayerController</strong> possesses Pawn, owns HUD</div>
                <div class="relationship-item"><strong>PlayerState</strong> persists across Pawn deaths</div>
                <div class="relationship-item"><strong>GameState</strong> holds all PlayerStates</div>
                <div class="relationship-item"><strong>GameInstance</strong> persists across levels</div>
            </div>
        </div>
    </div>
    
    <div class="info-panel" id="info-panel">
        <button class="close-btn" onclick="closeInfoPanel()">Ã—</button>
        <h2 id="info-title"></h2>
        <p id="info-desc"></p>
        <div class="key-points" id="info-points"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Panel toggle function (desktop)
        window.togglePanel = function(panelId) {
            const panel = document.getElementById(panelId);
            panel.classList.toggle('collapsed');
        }
        
        // Mobile drawer toggle
        window.toggleDrawer = function() {
            const drawer = document.getElementById('mobile-drawer');
            drawer.classList.toggle('collapsed');
        }
        
        // Tab switching
        window.switchTab = function(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.add('hidden');
            });
            
            // Deactivate all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById('tab-' + tabName).classList.remove('hidden');
            
            // Activate clicked button
            event.target.classList.add('active');
        }
        
        // Hide touch hint after first interaction
        let touchHintHidden = false;
        function hideTouchHint() {
            if (!touchHintHidden) {
                document.getElementById('touch-hint').classList.add('hidden');
                touchHintHidden = true;
            }
        }
        
        // Scene setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for performance
        renderer.setClearColor(0x0a0a0f, 1);
        container.appendChild(renderer.domElement);
        
        // Camera position
        camera.position.set(15, 12, 20);
        camera.lookAt(0, 0, 0);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);
        
        const pointLight1 = new THREE.PointLight(0x0088ff, 1, 50);
        pointLight1.position.set(-10, 10, 10);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xff4444, 0.5, 50);
        pointLight2.position.set(10, -5, -10);
        scene.add(pointLight2);
        
        // Class data with positions and info
        const classData = {
            'GameMode': {
                position: [0, 8, 0],
                color: 0xff4444,
                zone: 'server-only',
                description: 'The authority on game rules. Exists ONLY on the server - clients cannot access it directly. Handles player spawning, game flow, win conditions, and determines which Pawn/PlayerController classes to use.',
                keyPoints: ['Server Authority', 'Spawns Players', 'Game Rules', 'Match Flow']
            },
            'GameState': {
                position: [0, 4, 0],
                color: 0x44ff88,
                zone: 'all-clients',
                description: 'The replicated "shadow" of GameMode. Contains public game information that all clients need: match time, team scores, objectives, and a list of all PlayerStates. This is how clients know about the game state.',
                keyPoints: ['Replicated to All', 'Public Game Data', 'Team Scores', 'PlayerState Array']
            },
            'PlayerController': {
                position: [-6, 2, 4],
                color: 0xffaa44,
                zone: 'owning-client',
                description: 'The player\'s "brain" - handles input and possesses Pawns. Exists on server and ONLY the owning client (not other clients). This is why you can\'t access another player\'s PlayerController.',
                keyPoints: ['Input Handler', 'Possesses Pawn', 'Server + Owner Only', 'Persists on Death']
            },
            'PlayerState': {
                position: [6, 2, 4],
                color: 0x44ff88,
                zone: 'all-clients',
                description: 'Player-specific data that everyone needs to see: name, score, team, stats. Replicated to ALL clients. Use this for scoreboard data, not PlayerController. Persists across Pawn deaths.',
                keyPoints: ['Replicated to All', 'Player Score/Name', 'Survives Pawn Death', 'Scoreboard Data']
            },
            'Pawn': {
                position: [0, -2, 6],
                color: 0x44ff88,
                zone: 'all-clients',
                description: 'The physical body in the game world. Replicated to all clients so everyone can see each other. Can be destroyed (player death) and respawned. Character is a specialized Pawn with movement.',
                keyPoints: ['Physical Body', 'Replicated to All', 'Can Be Destroyed', 'Possessed by Controller']
            },
            'Character': {
                position: [0, -5, 6],
                color: 0x44ff88,
                zone: 'all-clients',
                description: 'A specialized Pawn with built-in CharacterMovementComponent, capsule collision, and skeletal mesh support. The standard choice for humanoid player characters with walking/jumping.',
                keyPoints: ['Extends Pawn', 'Movement Component', 'Skeletal Mesh', 'Capsule Collision']
            },
            'HUD': {
                position: [-8, -2, 0],
                color: 0xaa44ff,
                zone: 'local-only',
                description: 'The player\'s UI interface - exists ONLY on each client locally. The server does NOT have HUD instances. Each player has their own HUD that other players cannot see or access. Now mostly replaced by UMG widgets.',
                keyPoints: ['Client Only', 'No Server Instance', 'Per-Player View', 'Canvas Rendering']
            },
            'GameInstance': {
                position: [8, -2, -4],
                color: 0xaa44ff,
                zone: 'local-only',
                description: 'Persists across level loads - the ONLY class that survives map travel. Each machine (server and clients) has its own separate instance. Perfect for storing settings, account data, and persistent stats.',
                keyPoints: ['Survives Level Load', 'Local Per-Machine', 'Persistent Data', 'Not Replicated']
            },
            'AIController': {
                position: [6, 5, -4],
                color: 0xff4444,
                zone: 'server-only',
                description: 'The "brain" for AI-controlled Pawns. Like PlayerController but for NPCs. Runs on server only - clients don\'t need to simulate AI decisions. Behavior Trees run through this class.',
                keyPoints: ['Server Only', 'AI Logic', 'Behavior Trees', 'Possesses AI Pawns']
            }
        };
        
        // Create zone platforms
        function createZonePlatform(y, color, size, opacity = 0.1) {
            const geometry = new THREE.BoxGeometry(size, 0.1, size);
            const material = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: opacity 
            });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.y = y;
            
            // Add grid lines
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.3 }));
            line.position.y = y;
            
            scene.add(platform);
            scene.add(line);
        }
        
        // Add zone platforms
        createZonePlatform(7, 0xff4444, 12, 0.05); // Server zone
        createZonePlatform(3, 0x44ff88, 18, 0.05); // Replicated zone
        createZonePlatform(-1, 0xffaa44, 14, 0.05); // Mixed zone
        
        // Store meshes for raycasting
        const classMeshes = [];
        const labels = [];
        
        // Create class boxes
        function createClassBox(name, data) {
            const group = new THREE.Group();
            
            // Main box
            const geometry = new THREE.BoxGeometry(2.5, 1.5, 2.5);
            const material = new THREE.MeshPhongMaterial({ 
                color: data.color,
                emissive: data.color,
                emissiveIntensity: 0.2,
                shininess: 100
            });
            const box = new THREE.Mesh(geometry, material);
            box.userData = { name: name, data: data };
            
            // Glow effect
            const glowGeometry = new THREE.BoxGeometry(2.7, 1.7, 2.7);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: data.color, 
                transparent: true, 
                opacity: 0.15 
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            
            // Edges
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.5 
            }));
            
            group.add(glow);
            group.add(box);
            group.add(line);
            group.position.set(...data.position);
            
            scene.add(group);
            classMeshes.push(box);
            
            // Create floating label
            createLabel(name, data.position, data.color);
            
            return group;
        }
        
        // Create text labels using sprites
        function createLabel(text, position, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(10, 10, 20, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.strokeStyle = `#${color.toString(16).padStart(6, '0')}`;
            context.lineWidth = 2;
            context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
            
            context.font = 'bold 24px Orbitron, sans-serif';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(position[0], position[1] + 1.5, position[2]);
            sprite.scale.set(4, 1, 1);
            
            scene.add(sprite);
            labels.push(sprite);
        }
        
        // Create connection lines between classes
        function createConnection(from, to, color = 0x0088ff, dashed = false) {
            const points = [
                new THREE.Vector3(...classData[from].position),
                new THREE.Vector3(...classData[to].position)
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            let material;
            if (dashed) {
                material = new THREE.LineDashedMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: 0.4,
                    dashSize: 0.3,
                    gapSize: 0.2
                });
            } else {
                material = new THREE.LineBasicMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: 0.4 
                });
            }
            
            const line = new THREE.Line(geometry, material);
            if (dashed) line.computeLineDistances();
            scene.add(line);
        }
        
        // Create all class boxes
        Object.entries(classData).forEach(([name, data]) => {
            createClassBox(name, data);
        });
        
        // Create connections
        createConnection('GameMode', 'GameState', 0x44ff88);
        createConnection('GameMode', 'PlayerController', 0xffaa44);
        createConnection('GameMode', 'PlayerState', 0x44ff88);
        createConnection('GameMode', 'AIController', 0xff4444);
        createConnection('PlayerController', 'Pawn', 0x00ffff);
        createConnection('PlayerController', 'PlayerState', 0xffaa44, true);
        createConnection('PlayerController', 'HUD', 0xaa44ff);
        createConnection('GameState', 'PlayerState', 0x44ff88, true);
        createConnection('Pawn', 'Character', 0x44ff88);
        createConnection('AIController', 'Pawn', 0xff4444, true);
        
        // Add grid
        const gridHelper = new THREE.GridHelper(30, 30, 0x222233, 0x111122);
        gridHelper.position.y = -8;
        scene.add(gridHelper);
        
        // Add axis indicator
        const axisGroup = new THREE.Group();
        const axisLength = 2;
        
        // Create small axis in corner
        const xAxis = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(axisLength, 0, 0)]),
            new THREE.LineBasicMaterial({ color: 0xff0000 })
        );
        const yAxis = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, axisLength, 0)]),
            new THREE.LineBasicMaterial({ color: 0x00ff00 })
        );
        const zAxis = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, axisLength)]),
            new THREE.LineBasicMaterial({ color: 0x0000ff })
        );
        
        axisGroup.add(xAxis);
        axisGroup.add(yAxis);
        axisGroup.add(zAxis);
        axisGroup.position.set(-12, -6, -12);
        scene.add(axisGroup);
        
        // Add particles for atmosphere
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 500;
        const posArray = new Float32Array(particlesCount * 3);
        
        for (let i = 0; i < particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 50;
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.05,
            color: 0x0088ff,
            transparent: true,
            opacity: 0.5
        });
        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);
        
        // Mouse and Touch controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotationX = 0;
        let targetRotationY = 0;
        let currentRotationX = 0;
        let currentRotationY = 0;
        let cameraDistance = 25;
        
        // Touch variables
        let lastTouchDistance = 0;
        let touchStartTime = 0;
        
        // Mouse events
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
            hideTouchHint();
        });
        
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                targetRotationY += deltaX * 0.005;
                targetRotationX += deltaY * 0.005;
                targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        renderer.domElement.addEventListener('mouseleave', () => {
            isDragging = false;
        });
        
        // Touch events
        renderer.domElement.addEventListener('touchstart', (e) => {
            hideTouchHint();
            touchStartTime = Date.now();
            
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY 
                };
            } else if (e.touches.length === 2) {
                isDragging = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1 && isDragging) {
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;
                
                targetRotationY += deltaX * 0.008;
                targetRotationX += deltaY * 0.008;
                targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));
                
                previousMousePosition = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY 
                };
            } else if (e.touches.length === 2) {
                // Pinch zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (lastTouchDistance > 0) {
                    const delta = lastTouchDistance - distance;
                    cameraDistance += delta * 0.05;
                    cameraDistance = Math.max(10, Math.min(50, cameraDistance));
                }
                
                lastTouchDistance = distance;
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchend', (e) => {
            // Check for tap (short touch) on a class
            const touchDuration = Date.now() - touchStartTime;
            if (touchDuration < 200 && e.changedTouches.length === 1) {
                const touch = e.changedTouches[0];
                handleTap(touch.clientX, touch.clientY);
            }
            
            isDragging = false;
            lastTouchDistance = 0;
        });
        
        // Zoom
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.02;
            cameraDistance = Math.max(10, Math.min(50, cameraDistance));
            hideTouchHint();
        }, { passive: false });
        
        // Handle tap/click on classes
        function handleTap(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(classMeshes);
            
            if (intersects.length > 0) {
                const selected = intersects[0].object;
                showInfo(selected.userData.name, selected.userData.data);
            }
        }
        
        // Click to select (desktop)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        renderer.domElement.addEventListener('click', (e) => {
            if (isDragging) return;
            handleTap(e.clientX, e.clientY);
        });
        
        // Info panel functions
        function showInfo(name, data) {
            const panel = document.getElementById('info-panel');
            const title = document.getElementById('info-title');
            const desc = document.getElementById('info-desc');
            const points = document.getElementById('info-points');
            
            const zoneColors = {
                'server-only': { bg: '#ff4444', text: 'SERVER ONLY' },
                'all-clients': { bg: '#44ff88', text: 'REPLICATED TO ALL' },
                'owning-client': { bg: '#ffaa44', text: 'SERVER + OWNER' },
                'local-only': { bg: '#aa44ff', text: 'LOCAL ONLY' }
            };
            
            const zone = zoneColors[data.zone];
            title.innerHTML = `${name} <span class="badge" style="background: ${zone.bg}; color: #000;">${zone.text}</span>`;
            desc.textContent = data.description;
            
            points.innerHTML = data.keyPoints.map(point => 
                `<span class="key-point">${point}</span>`
            ).join('');
            
            panel.classList.add('active');
        }
        
        window.closeInfoPanel = function() {
            document.getElementById('info-panel').classList.remove('active');
        }
        
        // Reset view function
        function resetView() {
            targetRotationX = 0;
            targetRotationY = 0;
            cameraDistance = 25;
        }
        
        // Reset button click
        document.getElementById('reset-btn').addEventListener('click', resetView);
        
        // Keyboard reset
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                resetView();
            }
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Smooth camera rotation
            currentRotationX += (targetRotationX - currentRotationX) * 0.08;
            currentRotationY += (targetRotationY - currentRotationY) * 0.08;
            
            camera.position.x = Math.sin(currentRotationY) * Math.cos(currentRotationX) * cameraDistance;
            camera.position.y = Math.sin(currentRotationX) * cameraDistance + 5;
            camera.position.z = Math.cos(currentRotationY) * Math.cos(currentRotationX) * cameraDistance;
            camera.lookAt(0, 0, 0);
            
            // Animate particles
            particlesMesh.rotation.y += 0.0003;
            
            // Make labels always face camera
            labels.forEach(label => {
                label.quaternion.copy(camera.quaternion);
            });
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize mobile drawer as collapsed
        if (window.innerWidth <= 768) {
            document.getElementById('mobile-drawer').classList.add('collapsed');
        }
        
        // Hide touch hint after 5 seconds anyway
        setTimeout(() => {
            hideTouchHint();
        }, 5000);
    </script>
</body>
</html>
